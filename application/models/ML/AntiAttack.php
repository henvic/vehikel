<?php
/**
 * Class that helps the system to protect against malicious
 * attacks from non-identified users.
 * 
 * It helps identifying suspect activity and can be used
 * for limiting access to the resources of the website
 * 
 * The access codes works with a white list approach. 
 * If something strange is happening like trying to
 * login multiply times without success, the default
 * (access free) is hardened (ensure human).
 * 
 * If strange behavor still happens again and again,
 * the access is forbidden.
 * 
 * @author henrique vicente
 *
 */

class ML_AntiAttack extends ML_getModel
{
	/**
     * Access forbidden.
     */
    const ACCESS_FORBIDDEN               =  0;

    /**
     * Access not authorized, should ensure first if
     * the response is not generated by a computer (e.g., using captcha).
     */
    const ACCESS_ENSURE_HUMAN            = -1;

    /**
     * Access free.
     */
    const ACCESS_FREE                    =  1;
    
    const WRONG_CREDENTIAL                  = 'wrongCredential';
	
	protected $_name = "antiattack";
	
	public static function loadRules()
	{
		$AntiAttack = new self();
		if($AntiAttack->getCode() == ML_AntiAttack::ACCESS_FORBIDDEN)
    	{
    		throw new Exception('You are forbidden to access this resource.', 403);
    	}
	}
	
	public static function captchaElement()
	{
		$recaptcha = new Zend_Service_ReCaptcha(
        	Zend_Registry::get('config')->services->recaptcha->keys->public,
        	Zend_Registry::get('config')->services->recaptcha->keys->private);
		
        $recaptcha->setOption('theme', 'clean');
        
        $captcha = new Zend_Form_Element_Captcha('challenge',
              array('label' => 'Type the challenge below',
              		'captcha'        => 'ReCaptcha',
                    'captchaOptions' => array('captcha' => 'ReCaptcha', 'service' => $recaptcha)));
		
        return $captcha;
	}
	
	
    public static function log($reason)
    {
    	$AntiAttack = new self();
    	if(is_string($reason)) $reason = array($reason);
	    $AntiAttack->insert(array("ip" => $_SERVER['REMOTE_ADDR'], "annotations" => serialize($reason)));
	    return $AntiAttack->getAdapter()->lastInsertId();
    }
    
    public static function ensureHuman()
    {
    	return (self::getCode() == self::ACCESS_ENSURE_HUMAN) ? true : false;
    }
    
    public static function getCode()
    {
    	$AntiAttack = new self();
    	$registry = Zend_Registry::getInstance();
    	
    	if($registry->isRegistered('cacheAntiAttackBehavior')) return $registry->get('cacheAntiAttackBehavior');
    	
    	$select = $AntiAttack->select()->where("ip = ?", $_SERVER['REMOTE_ADDR'])->where("CURRENT_TIMESTAMP < TIMESTAMP(timestamp, '00:15:00')");
    	$ip = substr(long2ip(ip2long($_SERVER['REMOTE_ADDR'])), 0, -2).'%';
    	$select->orWhere("ip LIKE ?", $ip)->where("CURRENT_TIMESTAMP < TIMESTAMP(timestamp, '00:05:00')");
    	$loggedMetaInfo = $AntiAttack->fetchAll($select);
    	
    	//avoid DoS attacks... And if something happens with the connection with the database, it may be handy also.
    	if(!is_object($loggedMetaInfo)) $behavior = ML_AntiAttack::ACCESS_FORBIDDEN;
    	else {
    		$loggedMetaInfoData = $loggedMetaInfo->toArray();
    		$size = sizeof($loggedMetaInfoData);
    		if($size > 250) $behavior = ML_AntiAttack::ACCESS_FORBIDDEN;
    		elseif($size > 8) $behavior = ML_AntiAttack::ACCESS_ENSURE_HUMAN;
    		else $behavior = ML_AntiAttack::ACCESS_FREE; //It defaults to ACCESS_FREE 
    	}
    	
    	$registry->set("cacheAntiAttackBehavior", $behavior);
    	
    	return $behavior;
    }
    
    public function randomSHA1()
    {
    	$food = Array();
    	for($n = 0; $n < 35; $n++)
    	{
    		$food[] = mt_rand(100000, 999999);
 		   	if($n%4) {
    			$food[] = tan($food[$n-1] - $food[$n]);
    		}
    	}
    	shuffle($food);
    	
    	$secret = sha1(implode($food));
    	
    	return $secret;
    }
    
}
